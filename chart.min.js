/* Minimal Chart shim for the extension to avoid missing file errors.
   This implements a very small subset of Chart.js-like API used by popup.js:
   - new Chart(ctx, config) where config.type is 'doughnut' or 'bar'
   - dataset structure: config.data.labels[], config.data.datasets[0].data[], backgroundColor, borderColor
   - chart.destroy()
   It's intentionally tiny and only for visual placeholders within the extension popup.
*/
(function () {
    function drawDoughnut(ctx, labels, data, colors) {
        const total = data.reduce((a, b) => a + b, 0) || 1;
        const cx = ctx.canvas.width / 2;
        const cy = ctx.canvas.height / 2;
        const radius = Math.min(cx, cy) * 0.8;
        let start = -0.5 * Math.PI;
        for (let i = 0; i < data.length; i++) {
            const val = data[i];
            const angle = (val / total) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.fillStyle = (Array.isArray(colors) ? colors[i] : colors) || '#ccc';
            ctx.arc(cx, cy, radius, start, start + angle);
            ctx.closePath();
            ctx.fill();
            start += angle;
        }
        // hole
        ctx.beginPath();
        ctx.fillStyle = ctx.canvas.style.backgroundColor || '#fff';
        ctx.arc(cx, cy, radius * 0.55, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawBar(ctx, labels, data, color) {
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        const padding = 20;
        const max = Math.max(...data, 1);
        const barWidth = (w - padding * 2) / data.length * 0.7;
        ctx.fillStyle = color || '#45b7d1';
        for (let i = 0; i < data.length; i++) {
            const val = data[i];
            const barHeight = (val / max) * (h - padding * 2);
            const x = padding + i * ((w - padding * 2) / data.length) + (((w - padding * 2) / data.length - barWidth) / 2);
            const y = h - padding - barHeight;
            ctx.fillRect(x, y, barWidth, barHeight);
        }
    }

    function clearCanvas(ctx) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }

    window.Chart = function (ctx, config) {
        if (!ctx || !ctx.getContext) return { destroy: function () { } };
        this.ctx = ctx.getContext('2d');
        this.config = config || {};
        this.draw();
    };

    window.Chart.prototype.draw = function () {
        try {
            const ctx = this.ctx;
            const cfg = this.config || {};
            const type = (cfg.type || '').toLowerCase();
            const data = (cfg.data && cfg.data.datasets && cfg.data.datasets[0]) ? cfg.data.datasets[0].data : [];
            const labels = (cfg.data && cfg.data.labels) || [];
            const bg = (cfg.data && cfg.data.datasets && cfg.data.datasets[0] && cfg.data.datasets[0].backgroundColor) || '#45b7d1';
            // adapt canvas for device pixel ratio
            const canvas = ctx.canvas;
            const ratio = window.devicePixelRatio || 1;
            if (canvas._chartdpr !== ratio) {
                const w = canvas.clientWidth || canvas.width;
                const h = canvas.clientHeight || canvas.height;
                canvas.width = w * ratio;
                canvas.height = h * ratio;
                canvas.style.width = (w) + 'px';
                canvas.style.height = (h) + 'px';
                canvas._chartdpr = ratio;
                ctx.scale(ratio, ratio);
            }
            clearCanvas(ctx);
            if (type === 'doughnut' || type === 'pie') {
                drawDoughnut(ctx, labels, data, bg);
            } else if (type === 'bar') {
                drawBar(ctx, labels, data, (Array.isArray(bg) ? bg[0] : bg));
            } else {
                // fallback - simple line of values
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.fillText('Chart type not supported: ' + type, 10, 20);
            }
        } catch (e) {
            // swallow errors to avoid breaking popup
            try { console.error('Chart shim error', e); } catch (e) { }
        }
    };

    window.Chart.prototype.destroy = function () {
        // clear canvas
        if (this.ctx && this.ctx.canvas) {
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        }
    };

})();
